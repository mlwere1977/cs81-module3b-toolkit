# Reflection: Math Toolkit Builder

**Name:** Mukwaya Lwere  
**Class:** CS 81 JavaScript  
**Module:** 3B – Math Toolkit Builder  
**Date:** 07/03/2025


## These are the  patterns & surprises that I eccountered while coding this toolkit:

I discovered some intriguing patterns while creating the toolkit:

- The structure of many functions was the same: take one or more inputs, execute one operation, and then return the outcome. Writing clear, reusable code became simpler as a result.
- When utilized in larger programs, the logic behind `isEven()` and `isOdd()` is powerful despite being surprisingly simple—just a modulo check.
- The rapid expansion of the toolkit caught me off guard. It began as a single function and developed into a tiny collection of practical tools.

---

## These are some of the logic operations that challenged my thinking:

- The edge case of dividing by zero necessitated extra caution when using the `divide()` function. It served as a reminder that even basic mathematical operations can have exceptions that require tactful handling.
- Selecting meaningful variable names made it easier for me to understand the purpose of each function. It simplified the debugging and following of the logic.
- I was able to comprehend the purpose of each function better by writing comments that sounded natural rather than robotic.

---

## These are some of the real-world applications that the functions would be used in:

This kind of toolkit could be useful in many real-world scenarios:

-  **Web development**: Utilized in data processing tools, calculators, and form validation.
-  **Data analysis**: More intricate statistical operations are based on fundamental mathematical operations.
-  **Testing and learning**: This kind of toolkit is excellent for honing your debugging and reasoning abilities.
-  **Building blocks**: These features might be included in a broader utility library that is utilized in several different projects.

---

All things considered, this assignment made it clearer to me how strong, reusable code can be built from tiny, well-written functions.